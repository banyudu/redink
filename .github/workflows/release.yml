name: Release

on:
  push:
    tags:
      - 'v*'
  workflow_dispatch:

jobs:
  create-release:
    permissions:
      contents: write
    runs-on: ubuntu-latest
    outputs:
      release_id: ${{ steps.create-release.outputs.release_id }}
      release_upload_url: ${{ steps.create-release.outputs.upload_url }}
      release_body: "${{ steps.tag.outputs.release_body }}"
      tag: ${{ steps.tag.outputs.tag }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history including tags

      - name: Get version from tag
        id: tag
        run: |
          # Extract tag from GITHUB_REF
          if [[ "$GITHUB_REF" == refs/tags/* ]]; then
            TAG="${GITHUB_REF#refs/tags/}"
            VERSION="${TAG#v}"
          else
            echo "Error: This workflow must be triggered by a tag push (refs/tags/v*)"
            exit 1
          fi
          
          echo "ğŸ“‹ Extracted TAG: $TAG"
          echo "ğŸ“‹ Extracted VERSION: $VERSION"
          
          # Verify tag exists locally
          echo "ğŸ” Checking if tag exists locally..."
          if ! git tag -l "$TAG" | grep -q "^$TAG$"; then
            echo "âŒ Error: Tag $TAG not found in local repository"
            echo "Available local tags:"
            git tag -l | tail -10
            exit 1
          fi
          echo "âœ“ Tag exists locally"
          
          # Show tag details
          echo "ğŸ“‹ Tag commit: $(git rev-parse $TAG)"
          echo "ğŸ“‹ HEAD commit: $(git rev-parse HEAD)"
          
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "release_body=See the assets to download this version and install." >> $GITHUB_OUTPUT
          
          echo "âœ… Tag verified: $TAG (version: $VERSION)"

      - name: Verify tag on remote
        run: |
          TAG="${{ steps.tag.outputs.tag }}"
          
          echo "ğŸ” Verifying tag $TAG exists on GitHub remote..."
          
          # Wait for tag to be available on remote (with retry)
          max_attempts=10
          attempt=1
          
          while [ $attempt -le $max_attempts ]; do
            echo "Attempt $attempt/$max_attempts: Checking if tag exists on remote..."
            
            if gh api "repos/${{ github.repository }}/git/refs/tags/$TAG" &>/dev/null; then
              echo "âœ… Tag $TAG found on remote"
              
              # Get tag details
              tag_info=$(gh api "repos/${{ github.repository }}/git/refs/tags/$TAG")
              echo "ğŸ“‹ Remote tag SHA: $(echo "$tag_info" | jq -r '.object.sha')"
              break
            else
              echo "â³ Tag not yet available on remote, waiting 2 seconds..."
              sleep 2
              attempt=$((attempt + 1))
            fi
          done
          
          if [ $attempt -gt $max_attempts ]; then
            echo "âŒ Error: Tag $TAG not found on remote after $max_attempts attempts"
            echo "This might indicate the tag wasn't pushed successfully"
            exit 1
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Create Release
        id: create-release
        run: |
          TAG="${{ steps.tag.outputs.tag }}"
          VERSION="${{ steps.tag.outputs.version }}"
          
          echo "ğŸš€ Creating draft release for $TAG..."
          
          # Check if release already exists
          if gh release view "$TAG" &>/dev/null; then
            echo "â„¹ï¸  Release for $TAG already exists, using existing release"
          else
            echo "ğŸ“ Creating new draft release using GitHub API..."
            
            # Get the commit SHA for the tag
            TAG_REF=$(gh api "repos/${{ github.repository }}/git/refs/tags/$TAG")
            echo "ğŸ“‹ Tag ref response: $TAG_REF"
            
            TAG_OBJECT_SHA=$(echo "$TAG_REF" | jq -r '.object.sha')
            TAG_OBJECT_TYPE=$(echo "$TAG_REF" | jq -r '.object.type')
            echo "ğŸ“‹ Tag object SHA: $TAG_OBJECT_SHA"
            echo "ğŸ“‹ Tag object type: $TAG_OBJECT_TYPE"
            
            # If it's an annotated tag, dereference to get the commit SHA
            if [ "$TAG_OBJECT_TYPE" = "tag" ]; then
              echo "ğŸ” Annotated tag detected, dereferencing to commit..."
              TAG_SHA=$(gh api "repos/${{ github.repository }}/git/tags/$TAG_OBJECT_SHA" --jq '.object.sha')
              echo "ğŸ“‹ Commit SHA: $TAG_SHA"
            else
              TAG_SHA="$TAG_OBJECT_SHA"
              echo "ğŸ“‹ Lightweight tag, using SHA directly: $TAG_SHA"
            fi
            
            if [ -z "$TAG_SHA" ] || [ "$TAG_SHA" = "null" ]; then
              echo "âŒ Error: Failed to get valid commit SHA"
              exit 1
            fi
            
            # Create release via GitHub API (more reliable than gh release create)
            echo "ğŸ”§ Calling GitHub API to create release..."
            
            if ! release_response=$(gh api \
              --method POST \
              "repos/${{ github.repository }}/releases" \
              -f tag_name="$TAG" \
              -f target_commitish="$TAG_SHA" \
              -f name="Redink $VERSION" \
              -f body="${{ steps.tag.outputs.release_body }}" \
              -F draft=true \
              -F prerelease=false 2>&1); then
              echo "âŒ Error: API call failed"
              echo "Response: $release_response"
              exit 1
            fi
            
            echo "âœ… Created draft release via API"
            echo "ğŸ“‹ API Response (first 500 chars):"
            echo "$release_response" | head -c 500
          fi
          
          # Get the release details
          echo "ğŸ” Verifying release creation..."
          release_details=$(gh release view "$TAG" --json id,name,tagName,isDraft,url)
          echo "ğŸ“‹ Release details: $release_details"
          
          # Extract release ID from the details
          release_id=$(echo "$release_details" | jq -r '.id')
          
          if [ -z "$release_id" ] || [ "$release_id" = "null" ]; then
            echo "âŒ Error: Failed to get release ID from release view"
            echo "ğŸ” Debugging: Trying alternative methods..."
            
            # Try to get from API by tag
            echo "Method 1: Get by tag..."
            gh api "repos/${{ github.repository }}/releases/tags/$TAG" --jq '.id' || echo "Failed"
            
            # Try to get latest draft
            echo "Method 2: Get latest draft..."
            gh api "repos/${{ github.repository }}/releases" --jq '.[] | select(.draft==true) | {id, tag_name, name}' | head -5
            
            exit 1
          fi
          
          echo "âœ… Release ID: $release_id"
          echo "release_id=$release_id" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  build-tauri:
    needs: create-release
    permissions:
      contents: write
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: 'macos-14' # macOS 14 (Sonoma) on Apple Silicon
            args: '--target aarch64-apple-darwin'
            arch: 'aarch64'
            target: 'aarch64-apple-darwin'
            
          - platform: 'macos-15' # macOS 15 (Sequoia) on Intel
            args: '--target x86_64-apple-darwin'
            arch: 'x86_64'
            target: 'x86_64-apple-darwin'

    runs-on: ${{ matrix.platform }}
    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0  # Fetch all history including tags

      - name: Debug release info
        run: |
          echo "ğŸ” Build job starting for ${{ matrix.platform }}"
          echo "ğŸ“‹ Release ID: ${{ needs.create-release.outputs.release_id }}"
          echo "ğŸ“‹ Tag: ${{ needs.create-release.outputs.tag }}"
          echo "ğŸ“‹ Current branch/tag: $(git describe --tags --always)"
          echo "ğŸ“‹ Build args: ${{ matrix.args }}"

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Setup Node
        uses: actions/setup-node@v4
        with:
          node-version: 24

      - name: Install Rust stable
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      - name: Rust cache
        uses: swatinem/rust-cache@v2
        with:
          workspaces: './src-tauri -> target'
          cache-on-failure: true

      - name: Install dependencies (ubuntu only)
        if: matrix.platform == 'ubuntu-latest'
        run: |
          sudo apt-get update
          sudo apt-get install -y libwebkit2gtk-4.1-dev libappindicator3-dev librsvg2-dev patchelf protobuf-compiler

      - name: Install dependencies (macOS only)
        if: startsWith(matrix.platform, 'macos-')
        run: |
          brew install protobuf

      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV

      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-

      - name: Install frontend dependencies
        run: pnpm install --frozen-lockfile

      - name: Pre-build info
        run: |
          echo "ğŸ”§ About to build with tauri-action..."
          echo "ğŸ“‹ Release ID (type check): ${{ needs.create-release.outputs.release_id }}"
          echo "ğŸ“‹ Tag: ${{ needs.create-release.outputs.tag }}"
          echo "ğŸ“‹ Platform: ${{ matrix.platform }}"
          echo "ğŸ“‹ Target: ${{ matrix.target }}"

      - name: Build Tauri app
        id: tauri-build
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
          # Disable AVX-512 for x86_64 builds (not available on GitHub Actions runners)
          # Use AVX2 instead which is widely supported and still fast
          RUSTFLAGS: ${{ matrix.arch == 'x86_64' && '-C target-cpu=haswell' || '' }}
        with:
          # Pass release ID as string to ensure compatibility
          releaseId: "${{ needs.create-release.outputs.release_id }}"
          tagName: "${{ needs.create-release.outputs.tag }}"
          releaseName: "Redink ${{ needs.create-release.outputs.tag }}"
          args: ${{ matrix.args }}

      - name: Verify build artifacts
        if: always()
        run: |
          echo "ğŸ” Checking for built artifacts..."
          echo "ğŸ“‚ Target directory structure:"
          find src-tauri/target -name "*.dmg" -o -name "*.app" | head -20 || echo "No .dmg or .app files found"
          
          echo ""
          echo "ğŸ“¦ Checking bundle directory:"
          if [ -d "src-tauri/target/${{ matrix.target }}/release/bundle" ]; then
            ls -lah src-tauri/target/${{ matrix.target }}/release/bundle/
            find src-tauri/target/${{ matrix.target }}/release/bundle -type f | head -20
          else
            echo "âŒ Bundle directory not found"
          fi

      - name: Verify release assets
        if: always()
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "ğŸ” Checking release assets..."
          TAG="${{ needs.create-release.outputs.tag }}"
          echo "ğŸ“‹ Release tag: $TAG"
          echo ""
          echo "ğŸ“¦ Current assets:"
          gh release view "$TAG" --json assets --jq '.assets[] | {name: .name, size: .size}'

  publish-release:
    permissions:
      contents: write
    runs-on: ubuntu-latest
    needs: [create-release, build-tauri]

    steps:
      - uses: actions/checkout@v4
      
      - name: Publish Release
        run: |
          gh release edit ${{ needs.create-release.outputs.tag }} --draft=false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

